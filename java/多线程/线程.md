# 线程

## 进程： 程序执行的过程，通常一个进程包含若干个线程（至少有一个线程），线程是CPU调度和执行的单位。
## 程序运行时，即使没有创建线程，后台也会有多个线程，如主线程，gc线程
## main（）称之为主线程，为系统的入口，用于执行整个程序。
## 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的。
## 对同一份资源操作时，会存在资源抢夺问题，需要加入并发控制。
## 线程会带来额外的开销，如CPU调度时间，并发控制开销。
## 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致。

## 线程创建方式：Thread Class、Runnable 接口、Callable接口

## 继承Thread类
+ ### 子类继承Thread类具备多线程能力
+ ### 启动线程：子类对象 start()
+ ### 不建议使用：避免OOP单继承局限性
## 实现 Runnable 接口
+ ### 实现Runnable接口具有多线程能力
+ ### 启动线程：代理模式传入Thread对象中
+ ### 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用

## 停止线程
+ ### 应让线程自动停止

## 线程休眠
+ ### Thread.sleep()
+ ### 模拟倒计时

## 线程礼让
+ ### 礼让线程，让当前正在执行的线程暂停，但不阻塞
## Join
+ ### Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞。

## 线程状态
```java
Thread.State state = thread.getState();
```
## 线程优先级
```java
//查看优先级
Thread.currentThread().getPriority()
//设置优先级
Thread.setPriority(1);
```

## 守护线程
+ ### 线程分为用户线程和守护线程
+ ### 虚拟机必须确保用户线程执行完毕
+ ### 虚拟机不用等待守护线程执行完毕
+ ### 守护线程例子：后台记录操作日志，监控内存，垃圾回收等

## 线程同步
+ ### synchronized
## 死锁
+ ### 多个线程互相抱着对方需要的资源，然后形成僵持。
## Lock
+ ### lock是显式锁（手动开启和关闭锁），synchornized是隐式锁，出作用域自动释放。
+ ### lock 只有代码块锁，synchornized有代码锁和方法锁
+ ### 使用 lock 锁，jvm将花费较少的时间来调度线程，性能更好。并具有更好的扩展性
# 生产者消费者
## 线程通信-分析
+ ### 这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。
+ ### 对于生产者，没有生产产品之前要通知消费者等待，而生产了产品之后有需要通知消费者消费；对于消费者在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费。
+ ### 在生产消费者问题中，仅有synchronized是不够的，synchronized可阻止并发更新同一个共享资源，实现了同步；但不能用于实现不同线程之间消息传递（通信）
## 并发协作模型“生产者/消费者模式” 
## 管程法
+ ### 生产者：负责生产数据的模块（可能是方法，对象，线程，进程）
+ ### 消费者：负责处理数据的模块（可能是方法，对象，线程，进程）
+ ### 缓冲区：消费者不能直接使用生产者的数据，他们之间有个缓冲区
## 信号灯法
+ ### 使用标志符处理生产者与消费者
